/* IMPORTANT:
 * The following preprocessing flags are added to 
 * avoid compilation error when this headers are included in more than 1 times 
 */
#ifndef RR_GRAPH_H
#define RR_GRAPH_H

#include "context.h"
#include "chan_width.h"
#include "rr_indexed_data.h"

enum e_rr_graph_type {
    GRAPH_GLOBAL, /* One node per channel with wire capacity > 1 and full connectivity */
    GRAPH_BIDIR, /* Detailed bidirectional graph */
    GRAPH_UNIDIR, /* Detailed unidir graph, untilable */
    /* RESEARCH TODO: Get this option debugged */
    GRAPH_UNIDIR_TILEABLE /* Detail unidir graph with wire groups multiples of 2*L */
};
typedef enum e_rr_graph_type t_rr_graph_type;


typedef std::vector<std::vector<std::vector<std::vector<std::vector<int>>>>> t_rr_node_indices; //[0..num_rr_types-1][0..grid_width-1][0..grid_height-1][0..NUM_SIDES-1][0..max_ptc-1]

typedef std::vector<std::map<int,int>> t_arch_switch_fanin;

/* Class for a Routing Resource Graph
 * 
 */
class t_rr_graph : public Context {
  public:
    /* Methods to create/free/access/modify each member */

    int get_max_chan_width();

    /* Function related to accessing indexed data */
    std::vector<size_t> count_rr_segment_types();

    /* Most utilized functions */
    int seg_index_of_cblock(t_rr_type from_rr_type, int to_node);
    int seg_index_of_sblock(int from_node, int to_node);

    /* Add timing parameters */
    short t_rr_graph::find_create_rr_rc_data(const float R, const float C);
    void add_C_from_switches(int maxlen, float C_ipin_cblock);
    
    /* utilized function for build a global rr_graph */
    void update_global_rr_graph_capacity();

    /* RR graph edges */
    void init_rr_nodes_fan_in();
    void partition_rr_graph_edges();
    void alloc_and_load_edges(const t_rr_edge_info_set& rr_edges_to_create);

    /* Output a rr_graph into a file */
  public: 
    /* Basic data read/write function */
    t_rr_graph_type type() const { return type_; }
    t_rr_graph_type mutable_type() { return type_; }
    t_rr_graph_type get_type() { return type_; }
    void            set_type(t_rr_graph_type tmp) { type_ = tmp; return; }

  private: 
    /* Type of rr_graph */
    t_rr_graph_type type_;
  
    /* chan_width is for x|y-directed channels; i.e. between rows */
    t_chan_width chan_width_;
  
    /* Structures to define the routing architecture of the FPGA.           */
    std::vector<t_rr_node> rr_nodes_; /* autogenerated in build_rr_graph */
  
    std::vector<t_rr_indexed_data> rr_indexed_data_; /* [0 .. num_rr_indexed_data-1] */
  
    //Fly-weighted Resistance/Capacitance data for RR Nodes
    std::vector<t_rr_rc_data> rr_rc_data_;
  
    //The indicies of rr nodes of a given type at a specific x,y grid location
    t_rr_node_indices rr_node_indices_; //[0..NUM_RR_TYPES-1][0..grid.width()-1][0..grid.width()-1][0..size-1]
  
    std::vector<t_rr_switch_inf> rr_switch_inf_; /* autogenerated in build_rr_graph based on switch fan-in. [0..(num_rr_switches-1)] */
  
    int num_arch_switches_;
    t_arch_switch_inf *arch_switch_inf_; /* [0..(num_arch_switches-1)] */
  
    /** Attributes for each rr_node.
     * key:     rr_node index
     * value:   map of <attribute_name, attribute_value>
     */
    std::unordered_map<int, t_metadata_dict> rr_node_metadata_;
    /* Attributes for each rr_edge                                             *
     * key:     <source rr_node_index, sink rr_node_index, iswitch>            *
     * iswitch: Index of the switch type used to go from this rr_node to       *
     *          the next one in the routing.  OPEN if there is no next node    *
     *          (i.e. this node is the last one (a SINK) in a branch of the    *
     *          net's routing).                                                *
     * value:   map of <attribute_name, attribute_value>                       */
    std::unordered_map<std::tuple<int, int, short>,
        t_metadata_dict> rr_edge_metadata_;
  
    /*
     * switch_fanin_remap is only used for printing out switch fanin stats (the -switch_stats option)
     * array index: [0..(num_arch_switches-1)];
     * map key: num of all possible fanin of that type of switch on chip
     * map value: remapped switch index (index in rr_switch_inf)
     */
    std::vector<std::map<int, int>> switch_fanin_remap_;
};

#endif
